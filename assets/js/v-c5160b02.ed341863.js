"use strict";(self.webpackChunkyaomin=self.webpackChunkyaomin||[]).push([[1435],{3404:(e,a,r)=>{r.r(a),r.d(a,{data:()=>h});const h={key:"v-c5160b02",path:"/groovy/groovy_base.html",title:"Groovy",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"适用场景",slug:"适用场景",children:[{level:3,title:"风控安全——规则引擎",slug:"风控安全——规则引擎",children:[]},{level:3,title:"监控中心",slug:"监控中心",children:[]},{level:3,title:"活动营销",slug:"活动营销",children:[]}]}],filePathRelative:"groovy/groovy_base.md",git:{contributors:[{name:"Amin.Yao",email:"Amin.Yao@gaiaworks.cn",commits:1}]}}},2095:(e,a,r)=>{r.r(a),r.d(a,{default:()=>i});const h=(0,r(6252).uE)('<h1 id="groovy" tabindex="-1"><a class="header-anchor" href="#groovy" aria-hidden="true">#</a> Groovy</h1><h2 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h2><h3 id="风控安全——规则引擎" tabindex="-1"><a class="header-anchor" href="#风控安全——规则引擎" aria-hidden="true">#</a> 风控安全——规则引擎</h3><p>风控的规则引擎非常适合用 groovy 来实现，对抗黑产，策略人员每天都都会产出拦截规则，如果每次都需要发版，可能发完观测完后，该薅的羊毛都被黑产薅没了。</p><p>所以利用 groovy 脚本引擎的动态解析执行，使用规则脚本将查拦截规则抽象出来，快速部署，提升效率。</p><h3 id="监控中心" tabindex="-1"><a class="header-anchor" href="#监控中心" aria-hidden="true">#</a> 监控中心</h3><p>大型互联网系统，伴随着海量数据进入，各个层级的人员需要时时刻刻关注业务的各个维度指标，此时某个指标异常光靠人肉是没办法实现的。 此时需要监控中心介入，提前部署好异动规则，当异常发生时，监控中心发出告警通知到对应的规则创建人员，从而尽快查明原因，挽回资损。</p><p>此时要保证监控中心异常灵活，可以随时随地满足业务人员或者研发人员配置监控指标，测试我们可以使用 Groovy 条件表达式，满足灵活监控规则配置需求。</p><h3 id="活动营销" tabindex="-1"><a class="header-anchor" href="#活动营销" aria-hidden="true">#</a> 活动营销</h3><p>营销活动配置是我个人觉得最复杂的业务之一。活动模板多样，千人千面，不同人群看到的活动样式或者“奖品”不一。 且活动上线要快，效果回收，投入产出比等要能立即观测。</p><p>此时需要工程侧抽象出整个活动模板，在需要变化的地方嵌入 Groovy 脚本，这样就减少了测试和发版的时间，做到活动可线上配置化。</p>',11),i={render:function(e,a){return h}}}}]);