"use strict";(self.webpackChunkyaomin=self.webpackChunkyaomin||[]).push([[4463],{1749:(r,e,a)=>{a.r(e),a.d(e,{data:()=>l});const l={key:"v-5443dfbd",path:"/java/java_jvm_option.html",title:"JVM调优常用参数",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"GC常用参数",slug:"gc常用参数",children:[]},{level:2,title:"Parallel常用参数",slug:"parallel常用参数",children:[]},{level:2,title:"CMS常用参数",slug:"cms常用参数",children:[]},{level:2,title:"G1常用参数",slug:"g1常用参数",children:[]}],filePathRelative:"java/java_jvm_option.md",git:{contributors:[{name:"yaomin",email:"272991874@qq.com",commits:2}]}}},6858:(r,e,a)=>{a.r(e),a.d(e,{default:()=>o});var l=a(6252);const i=(0,l._)("h1",{id:"jvm调优常用参数",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#jvm调优常用参数","aria-hidden":"true"},"#"),(0,l.Uk)(" JVM调优常用参数")],-1),t={class:"table-of-contents"},n=(0,l.Uk)("GC常用参数"),b=(0,l.Uk)("Parallel常用参数"),X=(0,l.Uk)("CMS常用参数"),c=(0,l.Uk)("G1常用参数"),s=(0,l.uE)('<h2 id="gc常用参数" tabindex="-1"><a class="header-anchor" href="#gc常用参数" aria-hidden="true">#</a> GC常用参数</h2><p>-Xmn -Xms -Xmx -Xss<br> 年轻代 最小堆 最大堆 栈空间<br> -XX:+UseTLAB<br> 使用TLAB，默认打开<br> -XX:+PrintTLAB<br> 打印TLAB的使用情况<br> -XX:TLABSize<br> 设置TLAB大小<br> -XX:+DisableExplictGC<br> System.gc()不管用 ，FGC<br> -XX:+PrintGC<br> -XX:+PrintGCDetails<br> -XX:+PrintHeapAtGC<br> -XX:+PrintGCTimeStamps<br> -XX:+PrintGCApplicationConcurrentTime (低)<br> 打印应用程序时间<br> -XX:+PrintGCApplicationStoppedTime （低）<br> 打印暂停时长<br> -XX:+PrintReferenceGC （重要性低）<br> 记录回收了多少种不同引用类型的引用<br> -verbose:class<br> 类加载详细过程<br> -XX:+PrintVMOptions<br> -XX:+PrintFlagsFinal -XX:+PrintFlagsInitial</p><blockquote><ul><li>必须会用</li></ul></blockquote><p>-Xloggc:opt/log/gc.log<br> -XX:MaxTenuringThreshold<br> 升代年龄，最大值15<br> 锁自旋次数 -XX:PreBlockSpin 热点代码检测参数-XX:CompileThreshold 逃逸分析 标量替换 …<br> 这些不建议设置</p><h2 id="parallel常用参数" tabindex="-1"><a class="header-anchor" href="#parallel常用参数" aria-hidden="true">#</a> Parallel常用参数</h2><p>-XX:SurvivorRatio<br> -XX:PreTenureSizeThreshold<br> 大对象到底多大<br> -XX:MaxTenuringThreshold<br> -XX:+ParallelGCThreads<br> 并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同<br> -XX:+UseAdaptiveSizePolicy<br> 自动选择各区大小比例</p><h2 id="cms常用参数" tabindex="-1"><a class="header-anchor" href="#cms常用参数" aria-hidden="true">#</a> CMS常用参数</h2><p>-XX:+UseConcMarkSweepGC<br> -XX:ParallelCMSThreads<br> CMS线程数量<br> -XX:CMSInitiatingOccupancyFraction<br> 使用多少比例的老年代后开始CMS收集，默认是68%(近似值)，如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）<br> -XX:+UseCMSCompactAtFullCollection<br> 在FGC时进行压缩<br> -XX:CMSFullGCsBeforeCompaction<br> 多少次FGC之后进行压缩<br> -XX:+CMSClassUnloadingEnabled<br> -XX:CMSInitiatingPermOccupancyFraction<br> 达到什么比例时进行Perm回收<br> GCTimeRatio<br> 设置GC时间占用程序运行时间的百分比<br> -XX:MaxGCPauseMillis<br> 停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代</p><h2 id="g1常用参数" tabindex="-1"><a class="header-anchor" href="#g1常用参数" aria-hidden="true">#</a> G1常用参数</h2><p>-XX:+UseG1GC<br> -XX:MaxGCPauseMillis<br> 建议值，G1会尝试调整Young区的块数来达到这个值<br> -XX:GCPauseIntervalMillis<br> ？GC的间隔时间<br> -XX:+G1HeapRegionSize<br> 分区大小，建议逐渐增大该值，1 2 4 8 16 32。<br> 随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长<br> ZGC做了改进（动态区块大小）<br> G1NewSizePercent<br> 新生代最小比例，默认为5%<br> G1MaxNewSizePercent<br> 新生代最大比例，默认为60%<br> GCTimeRatio<br> GC时间建议比例，G1会根据这个值调整堆空间<br> ConcGCThreads<br> 线程数量<br> InitiatingHeapOccupancyPercent<br> 启动G1的堆空间占用比例</p>',10),o={render:function(r,e){const a=(0,l.up)("RouterLink");return(0,l.wg)(),(0,l.iD)(l.HY,null,[i,(0,l._)("nav",t,[(0,l._)("ul",null,[(0,l._)("li",null,[(0,l.Wm)(a,{to:"#gc常用参数"},{default:(0,l.w5)((()=>[n])),_:1})]),(0,l._)("li",null,[(0,l.Wm)(a,{to:"#parallel常用参数"},{default:(0,l.w5)((()=>[b])),_:1})]),(0,l._)("li",null,[(0,l.Wm)(a,{to:"#cms常用参数"},{default:(0,l.w5)((()=>[X])),_:1})]),(0,l._)("li",null,[(0,l.Wm)(a,{to:"#g1常用参数"},{default:(0,l.w5)((()=>[c])),_:1})])])]),s],64)}}}}]);