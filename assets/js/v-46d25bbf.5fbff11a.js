"use strict";(self.webpackChunkyaomin=self.webpackChunkyaomin||[]).push([[2962],{2570:(e,a,l)=>{l.r(a),l.d(a,{data:()=>t});const t={key:"v-46d25bbf",path:"/java/java_string.html",title:"String 属于基础的数据类型吗？",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"基础数据类型和引用数据类型",slug:"基础数据类型和引用数据类型",children:[]},{level:2,title:"相关知识",slug:"相关知识",children:[]},{level:2,title:"静态区",slug:"静态区",children:[]},{level:2,title:"堆区",slug:"堆区",children:[]},{level:2,title:"栈区",slug:"栈区",children:[]},{level:2,title:"文字常量区",slug:"文字常量区",children:[]}],filePathRelative:"java/java_string.md",git:{contributors:[{name:"yaomin",email:"272991874@qq.com",commits:2}]}}},1148:(e,a,l)=>{l.r(a),l.d(a,{default:()=>p});var t=l(6252);const i=(0,t._)("h1",{id:"string-属于基础的数据类型吗",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#string-属于基础的数据类型吗","aria-hidden":"true"},"#"),(0,t.Uk)(" String 属于基础的数据类型吗？")],-1),r={class:"table-of-contents"},n=(0,t.Uk)("基础数据类型和引用数据类型"),d=(0,t.Uk)("相关知识"),h=(0,t.Uk)("静态区"),u=(0,t.Uk)("堆区"),s=(0,t.Uk)("栈区"),o=(0,t.Uk)("文字常量区"),c=(0,t.uE)('<h2 id="基础数据类型和引用数据类型" tabindex="-1"><a class="header-anchor" href="#基础数据类型和引用数据类型" aria-hidden="true">#</a> 基础数据类型和引用数据类型</h2><blockquote><ul><li>基础数据类型表示简单的数字或字符</li></ul></blockquote><p>byte：在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0<br> short：短整型，在内存中占16位，即2个字节，取值范围-32768~32767，默认值0<br> int：在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0<br> long：在内存中占64位，即8个字节-2^63~2^63-1，默认值0L<br> float：在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0<br> double：在内存中占64位，即8个字节，默认值0<br> char：在内存中占占16位，即2个字节，取值范围0~65535，默认值为空<br> boolean：占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false</p><blockquote><ul><li>引用数据类型</li></ul></blockquote><p>String 类 接口类型 数组类型 枚举类型 注解类型</p>',5),b=["src"],f=(0,t.uE)('<h2 id="相关知识" tabindex="-1"><a class="header-anchor" href="#相关知识" aria-hidden="true">#</a> 相关知识</h2><h2 id="静态区" tabindex="-1"><a class="header-anchor" href="#静态区" aria-hidden="true">#</a> 静态区</h2><p>保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。</p><h2 id="堆区" tabindex="-1"><a class="header-anchor" href="#堆区" aria-hidden="true">#</a> 堆区</h2><p>一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错</p><h2 id="栈区" tabindex="-1"><a class="header-anchor" href="#栈区" aria-hidden="true">#</a> 栈区</h2><p>由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限</p><h2 id="文字常量区" tabindex="-1"><a class="header-anchor" href="#文字常量区" aria-hidden="true">#</a> 文字常量区</h2><p>常量字符串就是放在这里的。 程序结束后由系统释放。</p>',9),p={render:function(e,a){const l=(0,t.up)("RouterLink");return(0,t.wg)(),(0,t.iD)(t.HY,null,[i,(0,t._)("nav",r,[(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Wm)(l,{to:"#基础数据类型和引用数据类型"},{default:(0,t.w5)((()=>[n])),_:1})]),(0,t._)("li",null,[(0,t.Wm)(l,{to:"#相关知识"},{default:(0,t.w5)((()=>[d])),_:1})]),(0,t._)("li",null,[(0,t.Wm)(l,{to:"#静态区"},{default:(0,t.w5)((()=>[h])),_:1})]),(0,t._)("li",null,[(0,t.Wm)(l,{to:"#堆区"},{default:(0,t.w5)((()=>[u])),_:1})]),(0,t._)("li",null,[(0,t.Wm)(l,{to:"#栈区"},{default:(0,t.w5)((()=>[s])),_:1})]),(0,t._)("li",null,[(0,t.Wm)(l,{to:"#文字常量区"},{default:(0,t.w5)((()=>[o])),_:1})])])]),c,(0,t._)("img",{src:e.$withBase("/images/java-datatype.png"),alt:"datatype"},null,8,b),f],64)}}}}]);