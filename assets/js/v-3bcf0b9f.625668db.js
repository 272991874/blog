"use strict";(self.webpackChunkyaomin=self.webpackChunkyaomin||[]).push([[5054],{3068:(e,a,l)=>{l.r(a),l.d(a,{data:()=>r});const r={key:"v-3bcf0b9f",path:"/dataStructure/",title:"数据结构",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"一、线性表",slug:"一、线性表",children:[{level:3,title:"1.数组",slug:"_1-数组",children:[]},{level:3,title:"2.链表",slug:"_2-链表",children:[]}]},{level:2,title:"二、栈与队列",slug:"二、栈与队列",children:[]},{level:2,title:"三、树与二叉树",slug:"三、树与二叉树",children:[{level:3,title:"1.树",slug:"_1-树",children:[]},{level:3,title:"2.二叉树基本概念",slug:"_2-二叉树基本概念",children:[]},{level:3,title:"3.二叉查找树",slug:"_3-二叉查找树",children:[]},{level:3,title:"4.平衡二叉树",slug:"_4-平衡二叉树",children:[]},{level:3,title:"5.红黑树",slug:"_5-红黑树",children:[]}]},{level:2,title:"四、图",slug:"四、图",children:[]}],filePathRelative:"dataStructure/README.md",git:{contributors:[{name:"yaomin",email:"272991874@qq.com",commits:4}]}}},7943:(e,a,l)=>{l.r(a),l.d(a,{default:()=>g});var r=l(6252);const h=(0,r.uE)('<h1 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h1><h2 id="一、线性表" tabindex="-1"><a class="header-anchor" href="#一、线性表" aria-hidden="true">#</a> 一、线性表</h2><h3 id="_1-数组" tabindex="-1"><a class="header-anchor" href="#_1-数组" aria-hidden="true">#</a> 1.数组</h3><h3 id="_2-链表" tabindex="-1"><a class="header-anchor" href="#_2-链表" aria-hidden="true">#</a> 2.链表</h3><h2 id="二、栈与队列" tabindex="-1"><a class="header-anchor" href="#二、栈与队列" aria-hidden="true">#</a> 二、栈与队列</h2><h2 id="三、树与二叉树" tabindex="-1"><a class="header-anchor" href="#三、树与二叉树" aria-hidden="true">#</a> 三、树与二叉树</h2><h3 id="_1-树" tabindex="-1"><a class="header-anchor" href="#_1-树" aria-hidden="true">#</a> 1.树</h3><h3 id="_2-二叉树基本概念" tabindex="-1"><a class="header-anchor" href="#_2-二叉树基本概念" aria-hidden="true">#</a> 2.二叉树基本概念</h3><h3 id="_3-二叉查找树" tabindex="-1"><a class="header-anchor" href="#_3-二叉查找树" aria-hidden="true">#</a> 3.二叉查找树</h3><h3 id="_4-平衡二叉树" tabindex="-1"><a class="header-anchor" href="#_4-平衡二叉树" aria-hidden="true">#</a> 4.平衡二叉树</h3><h3 id="_5-红黑树" tabindex="-1"><a class="header-anchor" href="#_5-红黑树" aria-hidden="true">#</a> 5.红黑树</h3><h2 id="四、图" tabindex="-1"><a class="header-anchor" href="#四、图" aria-hidden="true">#</a> 四、图</h2><p>树存储结构 图存储结构</p><p>#字符串</p><p>#数组和广义表</p>',15),n={href:"https://zhuanlan.zhihu.com/p/78094287",target:"_blank",rel:"noopener noreferrer"},t=(0,r.Uk)("数组与链表"),i=(0,r.Uk)(" 数据的逻辑结构主要分为两种："),d=(0,r._)("ul",null,[(0,r._)("li",null,[(0,r._)("p",null,"线性的：就是连成一条线的结构，本文要讲的数组和链表就属于这一类，另外还有 队列、栈 等")]),(0,r._)("li",null,[(0,r._)("p",null,"非线性的：顾名思义，数据之间的关系是非线性的，比如 堆、树、图 等")]),(0,r._)("li",null,[(0,r._)("p",null,"数组的访问时间复杂度是 O(1)")]),(0,r._)("li",null,[(0,r._)("p",null,"数组插入和删除的时间复杂度是O(n)")])],-1),u=(0,r._)("p",null,"链表的时间插入删除的时间复杂度为O(1)，不过这里指的是找到节点之后纯粹的插入或删除动作所需的时间复杂度。 如果当前还未定位到指定的节点，只是拿到链表的Head，这个时候要去删除此链表中某个固定内容的节点，则需要先查找到那个节点，这个查找的动作又是一个遍历动作了，这个遍历查找的时间复杂度却是O(n)，两者加起来总的时间复杂度其实是O(n)的。",-1),c={href:"https://zhuanlan.zhihu.com/p/79435086",target:"_blank",rel:"noopener noreferrer"},s=(0,r.Uk)("堆栈"),_={href:"https://zhuanlan.zhihu.com/p/81018602",target:"_blank",rel:"noopener noreferrer"},o=(0,r.Uk)("队列"),p={href:"https://zhuanlan.zhihu.com/p/81952290",target:"_blank",rel:"noopener noreferrer"},f=(0,r.Uk)("递归"),b=(0,r._)("p",null,"http://c.biancheng.net/view/3361.html",-1),g={render:function(e,a){const l=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.iD)(r.HY,null,[h,(0,r._)("p",null,[(0,r._)("a",n,[t,(0,r.Wm)(l)]),i]),d,u,(0,r._)("p",null,[(0,r._)("a",c,[s,(0,r.Wm)(l)])]),(0,r._)("p",null,[(0,r._)("a",_,[o,(0,r.Wm)(l)])]),(0,r._)("p",null,[(0,r._)("a",p,[f,(0,r.Wm)(l)])]),b],64)}}}}]);