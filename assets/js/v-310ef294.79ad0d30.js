"use strict";(self.webpackChunkyaomin=self.webpackChunkyaomin||[]).push([[4857],{7034:(e,a,l)=>{l.r(a),l.d(a,{data:()=>t});const t={key:"v-310ef294",path:"/framework/uml_uc.html",title:"UC矩阵",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"framework/uml_uc.md",git:{contributors:[{name:"yaomin_java",email:"272991874@qq.com",commits:1}]}}},6418:(e,a,l)=>{l.r(a),l.d(a,{default:()=>m});var t=l(6252);const u=(0,t._)("h1",{id:"uc矩阵",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#uc矩阵","aria-hidden":"true"},"#"),(0,t.Uk)(" UC矩阵")],-1),r=(0,t._)("blockquote",null,[(0,t._)("p",null,"U/C矩阵是一张表格。它可以表示数据/功能系统化分析的结果。它的左边第一列列出系统中各功能的名称，上面第一行列出系统中各数据类的名称。表中在各功能与数据类的交叉处，填写功能与数据类的关系。")],-1),n=(0,t._)("p",null,"u/c矩阵",-1),c=["src"],i=(0,t._)("p",null,"这个方法将功能点和数据分别做为横纵坐标来组成一个二维矩阵，在横纵坐标的每个交叉点上标记功能点对数据的要求，即U(Use)和C (Create)。标记完成后，对功能点位置和数据位置在各自坐标系上进行调整，调整的目标是尽量将C放在整个矩阵的对角线上，这时，各个功能点对数据的交叉依赖是最小的。最后，再把相邻的一些功能点分组，由此来获得数据交叉依赖性最小，功能聚合最紧密的子系统。",-1),m={render:function(e,a){return(0,t.wg)(),(0,t.iD)(t.HY,null,[u,r,n,(0,t._)("img",{src:e.$withBase("/images/uml/uml-uc202108251.jpg"),alt:"uc"},null,8,c),i],64)}}}}]);