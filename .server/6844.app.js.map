{"version":3,"file":"6844.app.js","mappings":";;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ECrCA;;;;;ACA6E;AAC7E;AACA,CAAmC;AACnC;AACA,iDAAiD,2BAAa;AAC9D;AACA,SAAS,SAAS;AAClB;;;AAGA,oDAAe","sources":["webpack://yaomin/./docs/.vuepress/.temp/pages/framework/SPI_base.html.js","webpack://yaomin/./docs/.vuepress/.temp/pages/framework/SPI_base.html.vue","webpack://yaomin/./docs/.vuepress/.temp/pages/framework/SPI_base.html.vue?1e83"],"sourcesContent":["export const data = {\n  \"key\": \"v-6be2f84b\",\n  \"path\": \"/framework/SPI_base.html\",\n  \"title\": \"SPI机制\",\n  \"lang\": \"zh-CN\",\n  \"frontmatter\": {},\n  \"excerpt\": \"\",\n  \"headers\": [\n    {\n      \"level\": 2,\n      \"title\": \"什么是 SPI\",\n      \"slug\": \"什么是-spi\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"优点\",\n      \"slug\": \"优点\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"缺点\",\n      \"slug\": \"缺点\",\n      \"children\": []\n    }\n  ],\n  \"filePathRelative\": \"framework/SPI_base.md\",\n  \"git\": {\n    \"contributors\": [\n      {\n        \"name\": \"yaomin_java\",\n        \"email\": \"272991874@qq.com\",\n        \"commits\": 1\n      }\n    ]\n  }\n}\n","<h1 id=\"spi机制\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#spi机制\" aria-hidden=\"true\">#</a> SPI机制</h1>\n<h2 id=\"什么是-spi\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是-spi\" aria-hidden=\"true\">#</a> 什么是 SPI</h2>\n<p>SPI (Service Provider Interface)，主要是用来在框架中使用的，最常见和莫过于我们在访问数据库时候用到的java.sql.Driver接口了。</p>\n<p>你想一下首先市面上的数据库五花八门，不同的数据库底层协议的大不相同，所以首先需要定制一个接口，来约束一下这些数据库，使得 Java 语言的使用者在调用数据库的时候可以方便、统一的面向接口编程。</p>\n<p>数据库厂商们需要根据接口来开发他们对应的实现，那么问题来了，真正使用的时候到底用哪个实现呢？从哪里找到实现类呢？</p>\n<p>这时候 Java SPI 机制就派上用场了，不知道到底用哪个实现类和找不到实现类，我们告诉它不就完事了呗。</p>\n<p>大家都约定好将实现类的配置写在一个地方，然后到时候都去哪个地方查一下不就知道了吗？</p>\n<p>Java SPI 就是这样做的，约定在 Classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，然后文件里面记录的是此 jar 包提供的具体实现类的全限定名。</p>\n<p>这样当我们引用了某个 jar 包的时候就可以去找这个 jar 包的 META-INF/services/ 目录，再根据接口名找到文件，然后读取文件里面的内容去进行实现类的加载与实例化。</p>\n<blockquote>\n<p>我们常用的访问数据库时候用到的java.sql.Driver接口，Dubbo 都采用了 SPI 机制。</p>\n</blockquote>\n<h2 id=\"优点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优点\" aria-hidden=\"true\">#</a> 优点</h2>\n<ul>\n<li>实现解耦，使得接口的定义与具体业务实现分离，应用程序可以根据实际业务情况启用或替换具体组件。</li>\n</ul>\n<h2 id=\"缺点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#缺点\" aria-hidden=\"true\">#</a> 缺点</h2>\n<ul>\n<li>Java SPI 无法按需加载实现类。</li>\n<li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li>\n<li>加载不到实现类时抛出并不是真正原因的异常，错误很难定位。</li>\n</ul>\n<blockquote>\n<p>Java SPI 在查找扩展实现类的时候遍历 SPI 的配置文件并且将实现类全部实例化，\n假设一个实现类初始化过程比较消耗资源且耗时，但是你的代码里面又用不上它，这就产生了资源的浪费。</p>\n</blockquote>\n","import { ssrRender } from \"./SPI_base.html.vue?vue&type=template&id=bfcb49b2\"\nconst script = {}\nimport { ssrContextKey } from 'vue'\nscript.ssrRender = (...args) => {\n  const ssrContext = args[2].appContext.provides[ssrContextKey]\n  ssrContext._registeredComponents.add(\"D:\\\\yaomin\\\\WorkSpace\\\\yaomin_java2\\\\node_modules\\\\@vuepress\\\\bundler-webpack\\\\lib\\\\build\\\\ssr\\\\vuepressLoader.js!D:\\\\yaomin\\\\WorkSpace\\\\yaomin_java2\\\\node_modules\\\\vue-loader\\\\dist\\\\index.js??ruleSet[0].use[1]!D:\\\\yaomin\\\\WorkSpace\\\\yaomin_java2\\\\docs\\\\.vuepress\\\\.temp\\\\pages\\\\framework\\\\SPI_base.html.vue\")\n  return ssrRender(...args)\n}\n\n\nexport default script"],"names":[],"sourceRoot":""}