{"version":3,"file":"1102.app.js","mappings":";;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;EC3CA;;;;;ACA2F;AAC3F;AACA,CAAmC;AACnC;AACA,iDAAiD,2BAAa;AAC9D;AACA,SAAS,SAAS;AAClB;;;AAGA,kEAAe","sources":["webpack://yaomin/./docs/.vuepress/.temp/pages/java/java_extend_implements.html.js","webpack://yaomin/./docs/.vuepress/.temp/pages/java/java_extend_implements.html.vue","webpack://yaomin/./docs/.vuepress/.temp/pages/java/java_extend_implements.html.vue?9719"],"sourcesContent":["export const data = {\n  \"key\": \"v-6a8a1966\",\n  \"path\": \"/java/java_extend_implements.html\",\n  \"title\": \"继承 和 实现\",\n  \"lang\": \"zh-CN\",\n  \"frontmatter\": {},\n  \"excerpt\": \"\",\n  \"headers\": [\n    {\n      \"level\": 2,\n      \"title\": \"面向对象三个特征：封装、继承、多态。\",\n      \"slug\": \"面向对象三个特征-封装、继承、多态。\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"第一、联系\",\n      \"slug\": \"第一、联系\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"第二、区别\",\n      \"slug\": \"第二、区别\",\n      \"children\": []\n    },\n    {\n      \"level\": 2,\n      \"title\": \"总结：\",\n      \"slug\": \"总结\",\n      \"children\": []\n    }\n  ],\n  \"filePathRelative\": \"java/java_extend_implements.md\",\n  \"git\": {\n    \"contributors\": [\n      {\n        \"name\": \"yaomin\",\n        \"email\": \"272991874@qq.com\",\n        \"commits\": 1\n      }\n    ]\n  }\n}\n","<h1 id=\"继承-和-实现\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#继承-和-实现\" aria-hidden=\"true\">#</a> 继承 和 实现</h1>\n<h2 id=\"面向对象三个特征-封装、继承、多态。\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#面向对象三个特征-封装、继承、多态。\" aria-hidden=\"true\">#</a> 面向对象三个特征：封装、继承、多态。</h2>\n<ul>\n<li>\n<p>继承：如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。</p>\n</li>\n<li>\n<p>实现：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标</p>\n</li>\n</ul>\n<h2 id=\"第一、联系\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第一、联系\" aria-hidden=\"true\">#</a> 第一、联系</h2>\n<p>继承父类和实现接口都能实现代码重用，提高开发效率。提现了实物的传递性，继承关系达到复用的目的。</p>\n<h2 id=\"第二、区别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第二、区别\" aria-hidden=\"true\">#</a> 第二、区别</h2>\n<ol>\n<li>修饰不同</li>\n</ol>\n<p>不同的修饰符修饰；实现：implements，继承：extends；</p>\n<ol start=\"2\">\n<li>数量不同</li>\n</ol>\n<p>Java只支持“接口”的多继承,不支持“类“”的多继承；而继承在java中具有单根性,子类只能继承一个父类。</p>\n<p>总结为：单继承，多实现。</p>\n<ol start=\"3\">\n<li>属性不同</li>\n</ol>\n<p>在接口中只能定义全局常量（static final）,和无实现的方法；而在继承中可以定义属性方法,变量,常量等...</p>\n<ol start=\"4\">\n<li>调用不同</li>\n</ol>\n<p>某个接口被类实现时,在类中一定要实现接口中的抽象方法；而继承想调用那个方法就调用那个方法,毫无压力</p>\n<h2 id=\"总结\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#总结\" aria-hidden=\"true\">#</a> 总结：</h2>\n<p>接口是：对功能的描述（方法/行为），接口传达的意思是：拥有某种功能，能干嘛，比如：Serializable代表可序列化的。</p>\n<p>继承是：什么是一种什么，继承传达的意思是：is-a，比如：猫 是一个 动物，猫就是动物的子类。</p>\n","import { ssrRender } from \"./java_extend_implements.html.vue?vue&type=template&id=5955f9bc\"\nconst script = {}\nimport { ssrContextKey } from 'vue'\nscript.ssrRender = (...args) => {\n  const ssrContext = args[2].appContext.provides[ssrContextKey]\n  ssrContext._registeredComponents.add(\"D:\\\\yaomin\\\\WorkSpace\\\\yaomin_java2\\\\node_modules\\\\@vuepress\\\\bundler-webpack\\\\lib\\\\build\\\\ssr\\\\vuepressLoader.js!D:\\\\yaomin\\\\WorkSpace\\\\yaomin_java2\\\\node_modules\\\\vue-loader\\\\dist\\\\index.js??ruleSet[0].use[1]!D:\\\\yaomin\\\\WorkSpace\\\\yaomin_java2\\\\docs\\\\.vuepress\\\\.temp\\\\pages\\\\java\\\\java_extend_implements.html.vue\")\n  return ssrRender(...args)\n}\n\n\nexport default script"],"names":[],"sourceRoot":""}